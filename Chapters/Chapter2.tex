% Related Work

\chapter{Related Work} % Main chapter title

\label{Related Work} % For referencing the chapter elsewhere, use \ref{Chapter1} 

\lhead{Related Work \emph{Related Work}} % This is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------

\section{Schacham et al}
The motivation for the $ROP$ attack was \textit{The geometry of innocent of innocent flesh of a bone}
which describes $return-into-libc$ attack to be mounted on $x86$ executables that calls no 
functions at all. The research work describes attack which combines a large number of short 
instruction sequences to build gadgets that allow arbitrary computation. This paper has 
mentioned how to discover such instruction sequences by means of static analysis. 
\textit{Schacham et al} introduced $ROP$ technique by which an attacker can induce arbitrary behavior 
in a program whose control flow can be diverted without injecting any code. A return-oriented 
program chains together short instruction sequences already present in a program's address 
space, each of which ends in a $return$ instruction. This technique could eventually 
evade $W \oplus X$-style hardware protections of $x86$ machines.

%----------------------------------------------------------------------------------------

\section{Erik Buchanan et al}
\textit{When good instructions go bad : Generalizing ROP into RISC}, showed a generalized approach 
for return-oriented programming on the $SPARC$, a fixed instruction length $RISC$ architecture with 
structured control flow. It was the first research work to construct a Turing-complete library of 
code gadgets using snippets of the Solaris $libc$, a general purpose programming language, and a 
compiler for constructing return-oriented exploits.

%----------------------------------------------------------------------------------------

\section{Dullien et al}
\textit{A framework for automated architecture-independent gadget search}, introduced a framework 
of algorithms capable of locating a Turing-complete gadget set. The framework uses 
\textit{Reverse Engineering Intermediate Language} (REIL), machine code into an intermediate 
language which allows the framework to be used for many different CPU architectures with minimal 
architecture-dependent adjustments.

%----------------------------------------------------------------------------------------

\section{Ralf Hund et al}
The first automated \textit{Turing complete ROP-rootkit for Bypassing Kernel Code Integrity 
Protection Mechanisms} for Windows platform was described in this research work by 
\textit{Ralf Hund et al}. The framework is partitioned into three core components: $Constructor$ 
for gadget discovery, $Compiler$ provides a comparatively high-level language for programming in 
a return oriented way (converts the source binary to an intermediate high-level language to 
produce the final memory image of the program), Loader resolves the relative memory address to 
absolute address as the output of Compiler is position independent. $Q$ follows the similar 
structure in the system design.

%----------------------------------------------------------------------------------------

\section{Binary Analysis Platform}
\textit{Binary Analysis Platform} (BAP) makes it easy to analyze binary code by first 
lifting assembly instructions into a simple language called $BIL$ (the BAP Intermediate Language). 
Unlike assembly, $BIL$ only has a few language constructs, which makes it easy to analyze. 
The goal of $BAP$ is to make it easy to develop binary analysis techniques and tools. Which makes 
it perfect to build the higher analysis system on top of this. $Q$ is build on top of $BAP$.

%----------------------------------------------------------------------------------------

