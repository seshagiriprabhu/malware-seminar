% Summary

\chapter{Summary} % Main chapter title

\label{Summary} % For referencing the chapter elsewhere, use \ref{Chapter1} 

\lhead{Summary \emph{Summary}} % This is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------

\section{'Q' System}
\begin{center}
\includegraphics[scale=0.50]{Pictures/Q-Design.png}
\end{center}
\textbf{Source program}: Vulnerable program
\textbf{Target program}: $Q$'s high level language $QooL$

%----------------------------------------------------------------------------------------

\section{Gadget Discovery}
Finding gadgets in the vulnerable program using semantic program verification techniques.
$Q$ requires each gadget to satisfy four properties:

\begin{enumerate}
    \item \textbf{Functional}: Each gadget has a type that defines its function. 
    A gadget's type is specified semantically by a boolean predicate that must always be 
    true after executing the gadget.

    \item \textbf{Control Preserving}: Each gadget must be capable of transferring 
    control to another gadget. This means that the gadget must end with $ret$ or some
    semantically equivalent instruction sequence.
    
    \item \textbf{Known-Side-effects}: The gadget must not have unknown side-effects. 
    Eg: The gadget must not write to any undesired memory locations
    
    \item \textbf{Constant Stack Offset}: Most gadget types require the stack pointer 
    to increase by a constant offset after each execution
\end{enumerate}

\subsection{Gadget Types} 
The set of gadget types in $Q$ defines a new instruction set architecture (ISA) in 
which each gadget type functions as an instruction. For each and every gadgets a 
postcondition $\beta$ is defined which must hold true after the execution of it. An 
instruction sequence $I$ satisfies a postcondition $\beta$ if and only if the post 
condition is true after running $I$ from any starting state.


\subsection{Semantic Analysis}
Given $I$ is an instruction sequence and $\beta$ is the semantic definition, a 
program verification technique called weakest precondition describes when $I$ will 
terminate in a state satisfying $\beta$  $WP(I, \beta) \equiv true$.
Eg:  $movl$ $0xc(%eax)$, $%ebx;$ $ret$ is a $LOADMEMG$ gadget. $Q$ converts this 
to $final(%ebx)$ = $initial(M [%eax + 12])$.


\subsection{Algorithms}
Two algorithms are used for gadget discovery. The first algorithm tests using 
concrete randomized inputs to check whether the semantics of an instruction sequence
matches those of any gadget types and validity check of the weakest precondition.

\begin{center} 
\includegraphics[scale=1]{Pictures/Algorithm-1.png}
\end{center}

The second algorithm iterates over the executable bytes of the source program, 
disassembles them, checks for the presence of $ret$ instruction and if found then 
calls first algorithm as a subroutine. 

\begin{center} 
\includegraphics[scale=1]{Pictures/Galileo-Algorithm.png}
\end{center}


%----------------------------------------------------------------------------------------


\section{Gadget Arrangement}
Gadget arrangement is a way of implementing target program using different types 
of gadgets discovered from the vulnerable program. One of the major achievement 
of this research work is that if the most natural choice of gadget is not available,
$Q$ effectively tries to synthesize a combination of other gadgets that will have 
the same semantics due to their efficient semantic engine.

\subsection{Q's Language: QooL}
Enables users to easily interact with the exploited program's environment. $QooL$ 
is not turing complete. 

\subsection{Arrangements} 
A gadget arrangement is a tree in which vertices are gadget types and edge represents 
type of input to the next gadget from the output of the previous one. Gadget 
arrangement is done using maximal munch or longest matching algorithm. The algorithm 
considers the principle that when creating some arrangement, as much of the available 
input as possible should be consumed. It also assumes that any instruction selected as 
the best will always be available for use. A robust gadget arrangement algorithm 
cannot make assumptions. $Q$ employs every munch which builds tree representing all 
possible ways that gadget types can be arranged to perform a computation. The munch 
rules are applied recursively to the program being compiled in $Q$.

\subsection{Munch rules} 
In real case scenarios, many binaries do not contain gadgets for directly storing to 
memory. If $Q$ is able to set the value in memory to 0 or -1, it can use 
$ARITHMETICSTOREG$ gadget with mathematical identities to write an arbitrary value. 
An example:

\begin{center} 
\includegraphics[scale=1]{Pictures/apt-get.png}
\end{center}


%----------------------------------------------------------------------------------------

\section{Gadget Assignment}
As long as at least one of the gadget arrangements can be satisfied using the gadgets
it discovered in the source program, $Q$ cannot output a working $ROP$ payload. The 
goal is to assign gadgets found during the discovery to the vertices of arrangements 
and see if the assignments are compatible. If it is successful, the output is the 
mapping from gadget arrangement vertices to concrete gadgets. 

Gadget assignments needs a schedule, as the gadgets must execute in a particular order 
because there are data dependencies between different gadgets. Hence $Q$ strictly 
follows the below rules for gadget assignments:

\begin{enumerate}

    \item \textbf{Matching registers}: Two registers should match whenever the result 
    of gadget $a$ is used as input type for gadget $b$. i.e $OutReg(a)$ = 
    $InReg(b, type)$.

    \item \textbf{No register Clobbering}: If the output of gadget $a$ is used by 
    gadget $b$, then a's output register should be not altered by other gadgets which 
    are scheduled in between $a$ and $b$.  

\end{enumerate}


$Q$'s key observation about the gadget arrangement is that if a gadget arrangement 
\textbf{GA} is unsatisfiable, then any \textbf{GA'} that contains \textbf{GA} as subtree 
is also unsatisfiable. Gadget assignment is implemented using two algorithms. Algorithm 3 
is a caching wrapper which caches results and calls Algorithm 2 which uses brute force 
technique to go through all the possible gadget assignments on larger subtrees. In-order 
to reduce the time complexity of the algorithm, it has been designed in such a way that 
If the algorithm 3 fails on a subtree, it aborts the entire arrangement. $Q$ calls 
Algorithm 3 on each possible gadget arrangement until one is satisfied or there are none 
left.

\begin{center} 
\includegraphics[scale=1]{Pictures/Algorithm-2.png}
\end{center}

Data structures in Algorithm 2:

\begin{enumerate}
    \item \textbf{S}: $V-> N$; A one to one mapping between each vertex and its position
     in the current schedule.
    \item \textbf{G}: $V -> G$; The current assignment of each vertex to its assigned 
    gadget.
\end{enumerate}

\begin{center} 
\includegraphics[scale=1]{Pictures/Algorithm-3.png}
\end{center}

Data structures in Algorithm 3:
\begin{enumerate}
    \item \textbf{C}: $V -> {0, 1, ?}$ is a cache which maps a gadget arrangement 
    vertex to one of $true$, $false$ or $unknown$. 
\end{enumerate}


%----------------------------------------------------------------------------------------


\section{Creating Exploits that Bypass ASLR and DEP}
Given an input exploit or even a proof of concept crashing input, $Q$ is capable 
to provide an exploit which can bypass $ASLR$ and $DEP$.


\subsection{Generating formula from a concrete run}
At binary level, the recording tool incorporates dynamic taint analysis to keep 
track of the which instructions deal with the user input or derived data. $Q$ 
uses this information to keep track of the information to:

\begin{enumerate}
    \item Record the instruction that access or modifies the taint data.
    \item Halt the recording once control-hijacking takes place 
    (i.e when $EIP$ becomes tainted).
\end{enumerate}

After recording the concrete execution, $Q$ symbolically executes the target program, 
which is similar to normal execution, except that each input byte is replaced with 
symbol. Such that every computation involving symbolic input is related to a symbolic 
expression. Constraints on the input to follow the same execution path would be 
recorded as constraint formula $\Pi$. Constraint formula has all inputs that follow 
the vulnerable path. $Q$ uses two exploit constraints $\alpha$ is set true only if a
program's control flow has been diverted and $\Sigma$ maps to true, only if payload 
for desired computation is in the exploit. $Q$ uses $BAP$ to convert the binary 
instructions to an intermediate language for the ease of analysis.


\subsection{Exploit Constraint Generation}

\begin{enumerate}

    \item \textbf{Control Flow Hijacking constraints}: $\alpha$ takes the form 
    $jumpExp$ = $targetExp$, where $jumpExp$ is the symbolic expression representing 
    the target of the jump that tainted the instruction pointer, and $targetExp$ 
    depends on the exploit. For a typical stack exploit, $targetExp$ = $\&(shellcode)$ 
    and for $ROP$ payload, $targetExp$ = $\&(ret)$. This implies that $ROP$ payload 
    must be stored somewhere in the memory. 

    \item \textbf{Computation constraints}: Computation constraints ensure that the 
    computation payload is readily available in the memory in a known address at the 
    time of control flow hijacking. Computation constraints take the form 
    $\Sigma$ = $(mem[payloadBase]$ = $payload[0]$ $\bigwedge$ . . . $\bigwedge$ 
    $mem[payloadBase + n]$ = $payload[n])$, 
    where $payloadBase$ denotes the starting address of the payload in memory, and 
    payload denotes the bytes in the payload.

\end{enumerate}


%----------------------------------------------------------------------------------------


\section{Implementation details}

\begin{enumerate}

    \item $ROP$ component of $Q$ is built on top of Binary Analysis Platform.
    $BAP$ is used to:

    \begin{enumerate}
        \item Record assembly instructions into $BAP$ intermediate language.
        \item Symbolically execute the trace, to obtain constraint formula $\Pi$.
        \item Compute $\alpha$ and $\Sigma$.
    \end{enumerate}
    
    \item $ML$ code for gadget discovery, gadget arrangement and assignment phases
    \item Dynamic Taint analysis using Pin framework; tracing tool is optimized 
    to only record instructions that are user derived
    \item Simple Theorem Prover is used to determine the validity of generated 
    weakest preconditions and to find a satisfying answer to the resulting 
    constraint formula, uses the result to build exploit.

\end{enumerate}


%----------------------------------------------------------------------------------------


\section{Evaluation}

\subsection{Applicability}
Tested on 1,298 $ELF$ files in Ubuntu 9.10 $x86$ machine. For each program $P$, 
the research work has considered if $Q$ can create a $ROP$ payload to:

\begin{enumerate}

    \item \textbf{Call functions also called by P}: External functions called by $P$ 
    have an entry in the program's Procedure Linkage Table(PLT). 

    \item \textbf{Call external functions in libc}: Calling external functions that do
    not have a $PLT$ entry is more complicated. For this, a technique for calculating 
    the address of functions in $libc$ even when $libc$ is randomized. This involves 
    more computation than the above case, and so is more likely to be unsatisfiable.

    \item \textbf{Write to memory}: A payload which overwrites an arbitrary address

\end{enumerate}


\subsection{Results}
Previous research works shows that $ROP$ is more difficult when there is less binary 
code (< 100 $KB$). But the $Q$ has proved that  it can call linked functions in $80\%$ 
of programs that are $20KB$ or larger, and can call any function in linked shared 
libraries in $80\%$ of programs that are at least $100KB$ in size.

\begin{center} 
\includegraphics[scale=0.5]{Pictures/Q-success_rate.png}
(\textit{The probability that Q can generate various payload types})
\end{center}

\begin{center} 
\includegraphics[scale=0.5]{Pictures/Q-comparison.png}
(\textit{The difference in the probability of generating various payload types in other 
related works and $Q$ with respect to the size of binaries})
\end{center}


\subsection{Efficiency}
Semantic gadget arrangement is one of the novel technique used in this research work seems 
to be inefficient if used in a nonrandomized testing cases. Their results shows that $Q$ 
runs faster when randomized testing is enabled.

\begin{center} 
\includegraphics[scale=1]{Pictures/Q-efficiency.png}
\end{center}


\subsection{Exploit Hardening}
The research team has tested exploit hardening capability of the $Q$ system on already 
available public exploits of some GNU/Linux and Windows programs which are able to exploit 
only when $W \oplus X$ and $ASLR$ are disabled. The results shows that $Q$ system was able 
to harden exploits for several large, real program with the current security defences. 

\begin{center} 
\includegraphics[scale=0.60]{Pictures/Q-exploit-hardening.png}
\end{center}


%----------------------------------------------------------------------------------------
